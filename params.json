{"name":"Scalavro","tagline":"A runtime reflection-based Avro library in Scala.","body":"# Scalavro\r\n\r\nA runtime reflection-based Avro library in Scala.\r\n\r\nScalavro takes a code-first, reflection based approach to schema generation and (de)serialization.  This yields a very low-overhead interface, and imposes some costs.  In general, Scalavro assumes you know what types you're reading and writing.  No built-in support is provided (as yet) for so-called schema resolution (taking the writer's schema into account when reading data).\r\n\r\n## Goals\r\n\r\n1. To provide an in-memory representation of avro schemas and protocols.\r\n2. To synthesize avro schemas and protocols dynamically for a useful subset of Scala types.\r\n4. To dynamically generate Scala bindings for reading and writing Avro-mapped Scala types to and from Avro binary.\r\n5. Generally, to minimize fuss required to create an Avro-capable Scala application.\r\n\r\n## Obtaining Scalavro\r\n\r\nThe `Scalavro` artifacts are available from the Sonatype OSS Repository. The current release is `0.3.1`, built against Scala 2.10.2.  Synch to Maven Central is pending.\r\n\r\nUsing SBT:\r\n\r\n```scala\r\nresolvers += \"Sonatype OSS\" at \"https://oss.sonatype.org/content/repositories/releases/\"\r\n\r\nlibraryDependencies += \"com.gensler\" %% \"scalavro-io\" % \"0.3.1\"\r\n```\r\n\r\n## Index of Examples\r\n\r\n- [Arrays](#arrays)\r\n- [Maps](#maps)\r\n- [Enums](#enums)\r\n- [Unions](#unions)\r\n- [Fixed-Length Data](#fixed)\r\n- [Records](#records)\r\n- [Binary IO](#binary-io)\r\n\r\n## Type Mapping Strategy\r\n\r\n### Primitive Types\r\n\r\n<table>\r\n  <thead>\r\n  \t<tr>\r\n  \t  <th>Scala Type</th>\r\n  \t  <th>Avro Type</th>\r\n  \t</tr>\r\n  </thead>\r\n  <tbody>\r\n    <tr>\r\n      <td><code>\r\n        Unit\r\n      </code></td>\r\n      <td><code>\r\n        null\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td><code>\r\n        Boolean\r\n      </code></td>\r\n      <td><code>\r\n        boolean\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td><code>\r\n        Byte\r\n      </code></td>\r\n      <td><code>\r\n        int\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td><code>\r\n        Char\r\n      </code></td>\r\n      <td><code>\r\n        int\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td><code>\r\n        Short\r\n      </code></td>\r\n      <td><code>\r\n        int\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td><code>\r\n        Int\r\n      </code></td>\r\n      <td><code>\r\n        int\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td><code>\r\n        Long\r\n      </code></td>\r\n      <td><code>\r\n        long\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td><code>\r\n        Float\r\n      </code></td>\r\n      <td><code>\r\n        float\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td><code>\r\n        Double\r\n      </code></td>\r\n      <td><code>\r\n        double\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td><code>\r\n        String\r\n      </code></td>\r\n      <td><code>\r\n        string\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td><code>\r\n        scala.collection.Seq[Byte]\r\n      </code></td>\r\n      <td><code>\r\n        bytes\r\n      </code></td>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n\r\n### Complex Types\r\n\r\n<table>\r\n  <thead>\r\n  \t<tr>\r\n  \t  <th>Scala Type</th>\r\n  \t  <th>Avro Type</th>\r\n  \t</tr>\r\n  </thead>\r\n  <tbody>\r\n    <tr>\r\n      <td><code>\r\n        scala.collection.Seq[T]\r\n      </code></td>\r\n      <td><code>\r\n        array\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td><code>\r\n        scala.collection.Set[T]\r\n      </code></td>\r\n      <td><code>\r\n        array\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td><code>\r\n        scala.collection.Map[String, T]\r\n      </code></td>\r\n      <td><code>\r\n        map\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td><code>\r\n        scala.Enumeration#Value\r\n      </code></td>\r\n      <td><code>\r\n        enum\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td>\r\n        <code>enum</code> (Java)</td>\r\n      <td><code>\r\n        enum\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td><code>\r\n        scala.util.Either[A, B]\r\n      </code></td>\r\n      <td><code>\r\n        union\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td><code>\r\n        scala.util.Option[T]\r\n      </code></td>\r\n      <td><code>\r\n        union\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td><code>\r\n        com.gensler.scalavro.util.Union[U]\r\n      </code></td>\r\n      <td><code>\r\n        union\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td><code>\r\n        com.gensler.scalavro.util.FixedData\r\n      </code></td>\r\n      <td><code>\r\n        fixed\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td><em>\r\n        Supertypes of non-recursive case classes without type parameters\r\n      </em></td>\r\n      <td><code>\r\n        union\r\n      </code></td>\r\n    </tr>\r\n    <tr>\r\n      <td><em>\r\n        Non-recursive case classes without type parameters\r\n      </em></td>\r\n      <td><code>\r\n        record\r\n      </code></td>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n\r\n## General Information\r\n- Built against Scala 2.10.2 with SBT 0.12.4\r\n- Depends upon [spray-json](https://github.com/spray/spray-json)\r\n- The `io` sub-project depends upon the Apache Java implementation of Avro (Version 1.7.4)\r\n\r\n## Current Capabilities\r\n- Dynamic Avro schema generation from vanilla Scala types\r\n- Avro protocol definitions and schema generation\r\n- Convenient, dynamic binary IO\r\n- Avro RPC protocol representation and schema generation\r\n- Schema conversion to \"Parsing Canonical Form\" (useful for Avro RPC protocol applications)\r\n\r\n## Current Limitations\r\n- JSON IO is not yet implemented\r\n- Schema resolution (taking the writer's schema into account when reading) is not yet implemented\r\n- Recursive type dependencies are detected but not handled optimally -- potentially valid types are rejected at runtime.  For example, the current version cannot synthesize an Avro schema for a simple recursively defined linked list node.  Supporting this is a planned enhancement.\r\n\r\n## Scalavro by Example: Schema Generation\r\n\r\n<a name=\"arrays\"></a>\r\n### Arrays\r\n\r\n#### scala.Seq\r\n\r\n```scala\r\nimport com.gensler.scalavro.types.AvroType\r\nAvroType[Seq[String]].schema\r\n```\r\n\r\nWhich yields:\r\n\r\n```json\r\n{\r\n  \"type\" : \"array\",\r\n  \"items\" : \"string\"\r\n}\r\n```\r\n\r\n#### scala.Set\r\n\r\n```scala\r\nimport com.gensler.scalavro.types.AvroType\r\nAvroType[Set[String]].schema\r\n```\r\n\r\nWhich yields:\r\n\r\n```json\r\n{\r\n  \"type\" : \"array\",\r\n  \"items\" : \"string\"\r\n}\r\n```\r\n\r\n<a name=\"maps\"></a>\r\n### Maps\r\n\r\n```scala\r\nimport com.gensler.scalavro.types.AvroType\r\nAvroType[Map[String, Double]].schema\r\n```\r\n\r\nWhich yields:\r\n\r\n```json\r\n{\r\n  \"type\" : \"map\",\r\n  \"values\" : \"double\"\r\n}\r\n```\r\n\r\n<a name=\"enums\"></a>\r\n### Enums\r\n\r\n#### scala.Enumeration\r\n\r\n```scala\r\npackage com.gensler.scalavro.tests\r\nimport com.gensler.scalavro.types.AvroType\r\n\r\nobject CardinalDirection extends Enumeration {\r\n  type CardinalDirection = Value\r\n  val N, NE, E, SE, S, SW, W, NW = Value\r\n}\r\n\r\nimport CardinalDirection._\r\nAvroType[CardinalDirection].schema\r\n```\r\n\r\nWhich yields:\r\n\r\n```json\r\n{\r\n  \"name\" : \"CardinalDirection\",\r\n  \"type\" : \"enum\",\r\n  \"symbols\" : [\"N\",\"NE\",\"E\",\"SE\",\"S\",\"SW\",\"W\",\"NW\"],\r\n  \"namespace\" : \"com.gensler.scalavro.tests.CardinalDirection\"\r\n}\r\n```\r\n\r\n#### Java `enum`\r\n\r\nDefinition (Java):\r\n\r\n```java\r\npackage com.gensler.scalavro.tests;\r\nenum JCardinalDirection { N, NE, E, SE, S, SW, W, NW };\r\n```\r\n\r\nUse (Scala):\r\n\r\n```scala\r\nimport com.gensler.scalavro.types.AvroType\r\nimport com.gensler.scalavro.tests.JCardinalDirection\r\n\r\nAvroType[JCardinalDirection].schema\r\n```\r\n\r\nWhich yields:\r\n\r\n```json\r\n{\r\n  \"name\" : \"JCardinalDirection\",\r\n  \"type\" : \"enum\",\r\n  \"symbols\" : [\"N\",\"NE\",\"E\",\"SE\",\"S\",\"SW\",\"W\",\"NW\"],\r\n  \"namespace\" : \"com.gensler.scalavro.tests\"\r\n}\r\n```\r\n\r\n<a name=\"unions\"></a>\r\n### Unions\r\n\r\n#### scala.Either\r\n\r\n```scala\r\npackage com.gensler.scalavro.tests\r\nimport com.gensler.scalavro.types.AvroType\r\n\r\nAvroType[Either[Int, Boolean]].schema\r\n```\r\n\r\nWhich yields:\r\n\r\n```json\r\n[\"int\", \"boolean\"]\r\n```\r\n\r\nand\r\n\r\n```scala\r\nAvroType[Either[Seq[Double], Map[String, Seq[Int]]]].schema\r\n```\r\n\r\nWhich yields:\r\n\r\n```json\r\n[{\r\n  \"type\" : \"array\",\r\n  \"items\" : \"double\"\r\n},\r\n{\r\n  \"type\" : \"map\",\r\n  \"values\" : {\r\n    \"type\" : \"array\",\r\n    \"items\" : \"int\"\r\n  }\r\n}]\r\n```\r\n\r\n#### scala.Option\r\n\r\n```scala\r\npackage com.gensler.scalavro.tests\r\nimport com.gensler.scalavro.types.AvroType\r\n\r\nAvroType[Option[String]].schema\r\n```\r\n\r\nWhich yields:\r\n\r\n```json\r\n[\"null\", \"string\"]\r\n```\r\n\r\n#### com.gensler.scalavro.util.Union.union\r\n\r\n```scala\r\nimport com.gensler.scalavro.types.AvroType\r\nimport com.gensler.scalavro.util.Union._\r\n\r\nAvroType[union [Int] #or [String] #or [Boolean]].schema\r\n```\r\n\r\nWhich yields:\r\n\r\n```json\r\n[\"int\", \"string\", \"boolean\"]\r\n```\r\n\r\n<a name=\"fixed\"></a>\r\n### Fixed-Length Data\r\n\r\n```scala\r\npackage com.gensler.scalavro.tests\r\n\r\nimport com.gensler.scalavro.types.AvroType\r\nimport com.gensler.scalavro.util.FixedData\r\nimport scala.collection.immutable\r\n\r\n@FixedData.Length(16)\r\ncase class MD5(override val bytes: immutable.Seq[Byte])\r\n           extends FixedData(bytes)\r\n\r\nAvroType[MD5].schema\r\n```\r\n\r\nWhich yields:\r\n\r\n```json\r\n{\r\n  \"name\": \"MD5\",\r\n  \"type\": \"fixed\",\r\n  \"size\": 16,\r\n  \"namespace\": \"com.gensler.scalavro.tests\"\r\n}\r\n```\r\n\r\n<a name=\"records\"></a>\r\n### Records\r\n\r\n#### From case classes\r\n\r\n```scala\r\npackage com.gensler.scalavro.tests\r\nimport com.gensler.scalavro.types.AvroType\r\n\r\ncase class Person(name: String, age: Int)\r\n\r\nval personAvroType = AvroType[Person]\r\npersonAvroType.schema\r\n```\r\n\r\nWhich yields:\r\n\r\n```json\r\n{\r\n  \"name\": \"Person\",\r\n  \"type\": \"record\",\r\n  \"fields\": [\r\n    {\"name\": \"name\", \"type\": \"string\"},\r\n    {\"name\": \"age\", \"type\": \"int\"}\r\n  ],\r\n  \"namespace\": \"com.gensler.scalavro.tests\"\r\n}\r\n```\r\n\r\nAnd perhaps more interestingly:\r\n\r\n```scala\r\ncase class SantaList(nice: Seq[Person], naughty: Seq[Person])\r\n\r\nval santaListAvroType = AvroType[SantaList]\r\nsantaListAvroType.schema\r\n```\r\n\r\nWhich yields:\r\n\r\n```json\r\n{\r\n  \"name\": \"SantaList\",\r\n  \"type\": \"record\",\r\n  \"fields\": [\r\n    {\r\n      \"name\": \"nice\",\r\n      \"type\": {\"type\": \"array\", \"items\": \"Person\"}\r\n    },\r\n    {\r\n      \"name\": \"naughty\",\r\n      \"type\": {\"type\": \"array\", \"items\": \"Person\"}\r\n    }\r\n  ],\r\n  \"namespace\": \"com.gensler.scalavro.tests\"\r\n}\r\n```\r\n\r\n<a name=\"supertypes-of-case-classes\"></a>\r\n#### From supertypes of case classes\r\n\r\nGiven:\r\n\r\n```scala\r\nclass Alpha\r\nabstract class Beta extends Alpha\r\ncase class Gamma() extends Alpha\r\ncase class Delta() extends Beta\r\ncase class Epsilon[T]() extends Beta\r\n```\r\n\r\nUsage:\r\n\r\n```scala\r\nimport com.gensler.scalavro.AvroType\r\nAvroType[Alpha].schema\r\n```\r\n\r\nWhich yields:\r\n\r\n```json\r\n[\r\n  {\r\n    \"name\" : \"Delta\",\r\n    \"type\" : \"record\",\r\n    \"fields\" : [],\r\n    \"namespace\" : \"com.gensler.scalavro.tests\"\r\n  },\r\n  {\r\n    \"name\" : \"Gamma\",\r\n    \"type\" : \"record\",\r\n    \"fields\" : [],\r\n    \"namespace\" : \"com.gensler.scalavro.tests\"\r\n  }\r\n]\r\n```\r\n\r\nNote that in the above example:\r\n\r\n- `Alpha` is excluded from the union because it is not a case class\r\n- `Beta` is excluded from the union because it is abstract and not a case class\r\n- `Epsilon` is excluded from the union because it takes type parameters\r\n\r\n<a name=\"binary-io\"></a>\r\n## Scalavro by Example: Binary IO\r\n\r\n```scala\r\nimport com.gensler.scalavro.AvroType\r\nimport com.gensler.scalavro.io.AvroTypeIO\r\nimport com.gensler.scalavro.io.AvroTypeIO.Implicits._\r\nimport scala.util.{Try, Success, Failure}\r\n\r\ncase class Person(name: String, age: Int)\r\ncase class SantaList(nice: Seq[Person], naughty: Seq[Person])\r\n\r\nval santaList = SantaList(\r\n  nice = Seq(\r\n    Person(\"John\", 17),\r\n    Person(\"Eve\", 3)\r\n  ),\r\n  naughty = Seq(\r\n    Person(\"Jane\", 25),\r\n    Person(\"Alice\", 65)\r\n  )\r\n)\r\n\r\nval santaListType = AvroType[SantaList]\r\nval santaListIO = santaListType.io // implicitly: AvroTypeIO[SantaList]\r\n\r\nval outStream: java.io.OutputStream = // some stream...\r\n\r\nsantaListIO.write(santaList, outStream)\r\n\r\nval inStream: java.io.InputStream = // some stream...\r\n\r\nsantaListIO.read(inStream) match {\r\n  case Success(readResult) => // readResult is an instance of SantaList\r\n  case Failure(cause)      => // handle failure...\r\n}\r\n```\r\n\r\n## Reference\r\n1. [Current Apache Avro Specification](http://avro.apache.org/docs/current/spec.html)\r\n1. [Scala 2.10 Reflection Overview](http://docs.scala-lang.org/overviews/reflection/overview.html)\r\n1. [Great article on schema evolution in various serialization systems](http://martin.kleppmann.com/2012/12/05/schema-evolution-in-avro-protocol-buffers-thrift.html)\r\n1. [Wickedly clever technique for representing unboxed union types, proposed by Miles Sabin](http://chuusai.com/2011/06/09/scala-union-types-curry-howard)\r\n\r\n## Legal\r\nApache Avro is a trademark of The Apache Software Foundation.\r\n\r\nScalavro is distributed under the BSD 2-Clause License, the text of which follows:\r\n\r\nCopyright (c) 2013, Gensler  \r\nAll rights reserved.\r\n\r\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\r\n\r\n- Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\r\n\r\n- Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\r\n\r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}